Hashing is a technique used for storing and accessing the data efficiently 

Hashing involves in mapping data to a specific index in a hash table using hash function. it enables fast retrival of information based on its key

the best thing about hashing is we can perform actions like searching, inserting, and deltion in O(1) time on average

hashing is mainly used for implementing a set of distinct elements(keys) and dictionaries(key value pair)

let the list l = [1,2,3,6,8]

hash function be h(x) = x%10 

then our hash table will be = 
                                    [
                                        0
                                        1
                                        2
                                        3
                                        0
                                        0
                                        6
                                        0
                                        8
                                        0
                                    ] 
now we can access 8 in O(1) time we dont need O(n) time as in case of array

if i have a element say 11 then it will go for index 1 but the issue is there is already a element present 

to counter this problem we can do : 

-> seperate chaining : 
one of the most popular and commonly used techniques in order to handle collisions
The idea behind separate chaining is to implement the array as a linked list called a chain

Linked List or a Dynamic Sized Array is used to implement this technique. 
So when multiple elements are hashed into the same slot index, then these elements are inserted into a singly-linked list which is known as a chain. 

for example i append elements like 11,21,31,41 then all these will give a remainder of 1 which will hash at 1st index and numbers like 38, 53,66,23 will take indexes betweem 0-9, hence the hash table will become 

[
    0
    1 -> 11 -> 21 -> 31 -> 41
    2
    3 -> 53 -> 23
    0
    0
    6 -> 66
    0
    8 -> 38
    0
]

the traditional array would have been like [1,2,3,6,8,11,21,31,41,38,53,66,23]

now searching numbers like 23 or 38 would take a lot of time in array but in hash table, we check in the index, if element is there then true else we will search the linked list chained to that index which would be O(n) for worst case but will be better than array 

Advantages:
Simple to implement 
Hash table never fills up, we can always add more elements to the chain 
Less sensitive to the hash function or load factors 
It is mostly used when it is unknown how many and how frequently keys may be inserted or deleted

Disadvantages: 
The cache performance of chaining is not good as keys are stored using a linked list
Wastage of Space as Some Parts of the hash table are never used 
If the chain becomes long, then search time can become O(n) in the worst case
Uses extra space for links

let a = no of slots in the hash table 
    b = no of keys to be inserted into the hash table 

Load factor (x) = b/a

Expected time to search = O(1 + x)
Expected time to delete = O(1 + x)
Time to insert = O(1)

Another way of handling collision is open addressing

-> Open addressing:

all elements are stored in the hash table itself

So at any point, the size of the table must be greater than or equal to the total number of keys 

we can increase table size by copying old data if needed. This approach is also known as closed hashing

This entire procedure is based upon probing

key operations:
Insert(k): Keep probing until an empty slot is found. Once an empty slot is found, insert k. 
Search(k): Keep probing until the slot's key doesn't become equal to k or an empty slot is reached. 
Delete(k): If we simply delete a key, then the search may fail. So slots of deleted keys are marked specially as "deleted". 

The insert can insert an item in a deleted slot, but the search doesn't stop at a deleted slot.

Different ways of Open Addressing:

1. Linear probing

In linear probing, the hash table is searched sequentially that starts from the original location of the hash 
in case the location that we get is already occupied, then we check for the next location.

The function used for rehashing is: rehash(key) = (n+1)%table-size.

Let hash(x) be the slot index computed using a hash function and S be the table size 

If slot hash(x)%S is full, then we try (hash(x)+1)%S
If (hash(x)+1)%S is also full, then we try (hash(x)+2)%S
If (hash(x)+2)%S is also full, then we try (hash(x)+3)%S

let the hash table be :

[
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
]

insert 8

[
    0
    0
    0
    0
    0
    0
    0
    0
    8
    0
]

insert 12

[
    0
    0
    12
    0
    0
    0
    0
    0
    8
    0
]

insert 17

[
    0
    0
    12
    0
    0
    0
    0
    17
    8
    0
]

insert 25

[
    0
    0
    12
    0
    0
    25
    0
    17
    8
    0
]

insert 28 but wait index 8 is already full, then we will use (hash(x)+1)%S which gives index 9

[
    0
    0
    12
    0
    0
    25
    0
    17
    8
    28
]

insert 35 but index 5 is already taken so we will use (hash(x)+1)%S which gives index 6

[
    0
    0
    12
    0
    0
    25
    35
    17
    8
    28
]

insert 44 

[
    0
    0
    12
    0
    44
    25
    35
    17
    8
    28
]

insert 48 but index 8 is already taken lets check 9th index, it is also taken then we will check for another index through (hash(x)+2)%S which gives index 0

[
    48
    0
    12
    0
    44
    25
    35
    17
    8
    28
]

insert 55 but index 5 taken, lets check index 6 it already taken, after cheking for avalilable slots we got the index 1

[
    48
    55
    12
    0
    44
    25
    35
    17
    8
    28
]

insert 68 , since 8 is taken and after checking whole the avalilable slot is index 3

[
    48
    55
    12
    68
    44
    25
    35
    17
    8
    28
]

the problem with linear probing is clustering of elements, hence we use Quadratic probing for this issue

2. Quadratic probing

in this case the interval between probes will increase proportionally to the hash value.

Quadratic probing is a method with the help of which we can solve the problem of clustering that was occuring in linear probing

This method is also known as the mid-square method

In this method, we look for the i2'th slot in the ith iteration. 
We always start from the original hash location. If only the location is occupied then we check the other slots.

let hash(x) be the slot index computed using hash function.  

If slot hash(x)%S is full, then we try (hash(x)+1*1)%S
If (hash(x)+1*1)%S is also full, then we try (hash(x)+2*2)%S
If (hash(x)+2*2)%S is also full, then we try (hash(x)+3*3)%S

let the hash table be :

[
    0
    0
    0
    0
    0
    0
    0
]

insert 9

[
    0
    0
    9
    0
    0
    0
    0
]

insert 38

[
    0
    0
    9
    38
    0
    0
    0
]

insert 358

[
    0
    358
    9
    38
    0
    0
    0
]

insert 16 , but index 2 is already taken we use (hash(x)+1*1)%S which gives index 3 but that index is already taken, hence we use (hash(x)+2*2)%S which would be index 6

[
    0
    358
    9
    38
    0
    0
    16
]

instead of using 4th index we used 6th index for avoinding clustering

3. Double Hashing 

Double hashing is a technique that reduces clustering in an optimized way. 
In this technique, the increments for the probing sequence are computed by using another hash function. 
We use another hash function hash2(x) and look for the i*hash2(x) slot in the ith rotation. 

let hash(x) be the slot index computed using hash function.  

If slot hash(x) % S is full, then we try (hash(x) + 1*hash2(x)) % S
If (hash(x) + 1*hash2(x)) % S is also full, then we try (hash(x) + 2*hash2(x)) % S
If (hash(x) + 2*hash2(x)) % S is also full, then we try (hash(x) + 3*hash2(x)) % S

let the hash table be :

[
    0
    0
    0
    0
    0
    0
    0
]

insert 27

[
    0
    0
    0
    0
    0
    0
    27
]

insert 43

[
    0
    43
    0
    0
    0
    0
    27
]

insert 642
but index 6 is taken then we use double Hashing 
hnew = [h1(692)+i*h2(692)]%7
     = [6 + 1*(1+692%5)]%7
     = 9%7
     = 2


[
    0
    43
    642
    0
    0
    0
    27
]

insert 72
but index 2 is taken then we use double Hashing 
hnew = [h1(72)+i*h2(72)]%7
     = [2 + 1*(1+72%5)]%7
     = 5%7
     = 5

[
    0
    43
    642
    0
    0
    72
    27
]

Double hashing has poor cache performance but no clustering. Double hashing requires more computation time as two hash functions need to be computed.

The choice of collision handling technique can have a significant impact on the performance of a hash table 
Linear probing is simple and fast, but it can lead to clustering and can degrade performance 
Quadratic probing is more spaced out, but it can also lead to clustering and can result in a situation where some slots are never checked
Double hashing is more complex, but it can lead to more even distribution of keys and can provide better performance in some cases

