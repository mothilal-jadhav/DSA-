Hashing is a technique used for storing and accessing the data efficiently 

Hashing involves in mapping data to a specific index in a hash table using hash function. it enables fast retrival of information based on its key

the best thing about hashing is we can perform actions like searching, inserting, and deltion in O(1) time on average

hashing is mainly used for implementing a set of distinct elements(keys) and dictionaries(key value pair)

let the list l = [1,2,3,6,8]

hash function be h(x) = x%10 

then our hash table will be = 
                                    [
                                        0
                                        1
                                        2
                                        3
                                        0
                                        0
                                        6
                                        0
                                        8
                                        0
                                    ] 
now we can access 8 in O(1) time we dont need O(n) time as in case of array

if i have a element say 11 then it will go for index 1 but the issue is there is already a element present 

to counter this problem we can do : 

-> seperate chaining : 
one of the most popular and commonly used techniques in order to handle collisions
The idea behind separate chaining is to implement the array as a linked list called a chain

Linked List or a Dynamic Sized Array is used to implement this technique. 
So when multiple elements are hashed into the same slot index, then these elements are inserted into a singly-linked list which is known as a chain. 

for example i append elements like 11,21,31,41 then all these will give a remainder of 1 which will hash at 1st index and numbers like 38, 53,66,23 will take indexes betweem 0-9, hence the hash table will become 

[
    0
    1 -> 11 -> 21 -> 31 -> 41
    2
    3 -> 53 -> 23
    0
    0
    6 -> 66
    0
    8 -> 38
    0
]

the traditional array would have been like [1,2,3,6,8,11,21,31,41,38,53,66,23]

now searching numbers like 23 or 38 would take a lot of time in array but in hash table, we check in the index, if element is there then true else we will search the linked list chained to that index which would be O(n) for worst case but will be better than array 

Advantages:
Simple to implement 
Hash table never fills up, we can always add more elements to the chain 
Less sensitive to the hash function or load factors 
It is mostly used when it is unknown how many and how frequently keys may be inserted or deleted

Disadvantages: 
The cache performance of chaining is not good as keys are stored using a linked list
Wastage of Space as Some Parts of the hash table are never used 
If the chain becomes long, then search time can become O(n) in the worst case
Uses extra space for links

let a = no of slots in the hash table 
    b = no of keys to be inserted into the hash table 

Load factor (x) = b/a

Expected time to search = O(1 + x)
Expected time to delete = O(1 + x)
Time to insert = O(1)

Another way of handling collision is open addressing

-> Open addressing:

all elements are stored in the hash table itself

So at any point, the size of the table must be greater than or equal to the total number of keys 

we can increase table size by copying old data if needed. This approach is also known as closed hashing

This entire procedure is based upon probing

key operations:
Insert(k): Keep probing until an empty slot is found. Once an empty slot is found, insert k. 
Search(k): Keep probing until the slot's key doesn't become equal to k or an empty slot is reached. 
Delete(k): If we simply delete a key, then the search may fail. So slots of deleted keys are marked specially as "deleted". 

The insert can insert an item in a deleted slot, but the search doesn't stop at a deleted slot.

Different ways of Open Addressing:

1. Linear probing

In linear probing, the hash table is searched sequentially that starts from the original location of the hash 
in case the location that we get is already occupied, then we check for the next location.

The function used for rehashing is: rehash(key) = (n+1)%table-size.

Let hash(x) be the slot index computed using a hash function and S be the table size 

If slot hash(x)%S is full, then we try (hash(x)+1)%S
If (hash(x)+1)%S is also full, then we try (hash(x)+2)%S
If (hash(x)+2)%S is also full, then we try (hash(x)+3)%S

